labels = labels,
col = "black",
pos = 4,
cex = 0.6
)
# perform procrustes randomization test
protest(X = results_2,
Y = results_4,
scores = "sites",
permutations = 9999)
# perform procrustes randomization test
protest(X = results_3,
Y = results_4,
scores = "sites",
permutations = 9999)
# perform procrustes analyses
pro = procrustes(X = results_3,
Y = results_4,
symmetric = TRUE,
scale = TRUE)
print(pro)
labels = rownames(pro$X)
labels = gsub("site", "", labels)
# plot the results
par(mfrow = c(1, 2))
plot(pro, kind = 1, type = "n")
plot(pro, kind = 2)
par(mfrow = c(1,1))
plot(pro)
text(pro$X,
labels = labels,
col = "black",
pos = 4,
cex = 0.6
)
# perform procrustes randomization test
protest(X = results_3,
Y = results_4,
scores = "sites",
permutations = 9999)
# perform procrustes analyses
pro = procrustes(X = results_1,
Y = results_3,
symmetric = TRUE,
scale = TRUE)
print(pro)
labels = rownames(pro$X)
labels = gsub("site", "", labels)
# plot the results
par(mfrow = c(1, 2))
plot(pro, kind = 1, type = "n")
plot(pro, kind = 2)
par(mfrow = c(1,1))
plot(pro)
text(pro$X,
labels = labels,
col = "black",
pos = 4,
cex = 0.6
)
# perform procrustes randomization test
protest(X = results_1,
Y = results_3,
scores = "sites",
permutations = 9999)
# perform procrustes analyses
pro = procrustes(X = results_2,
Y = results_4,
symmetric = TRUE,
scale = TRUE)
print(pro)
labels = rownames(pro$X)
labels = gsub("site", "", labels)
# plot the results
par(mfrow = c(1, 2))
plot(pro, kind = 1, type = "n")
plot(pro, kind = 2)
par(mfrow = c(1,1))
plot(pro)
text(pro$X,
labels = labels,
col = "black",
pos = 4,
cex = 0.6
)
# perform procrustes randomization test
protest(X = results_2,
Y = results_4,
scores = "sites",
permutations = 9999)
# perform procrustes analyses
pro = procrustes(X = results_2,
Y = results_3,
symmetric = TRUE,
scale = TRUE)
print(pro)
labels = rownames(pro$X)
labels = gsub("site", "", labels)
# plot the results
par(mfrow = c(1, 2))
plot(pro, kind = 1, type = "n")
plot(pro, kind = 2)
par(mfrow = c(1,1))
plot(pro)
text(pro$X,
labels = labels,
col = "black",
pos = 4,
cex = 0.6
)
# perform procrustes randomization test
protest(X = results_2,
Y = results_3,
scores = "sites",
permutations = 9999)
# take out the scores from first two principal components
scores_1 = results_1$x[, 1:2]
scores_2 = results_2$x[, 1:2]
# check the dimensions - matrices must be the same dimensions
dim(scores_1)
dim(scores_2)
# make distance matrix from derived scores
dist_1 = dist(scores_1)
dist_2 = dist(scores_2)
# perform the Mantel test
mantel_result = mantel(dist_1,
dist_2,
method = "pearson",
permutations = 9999)
print(mantel_result)
# perform procrustes analyses
pro = procrustes(X = results_1,
Y = results_4,
symmetric = TRUE,
scale = TRUE)
print(pro)
labels = rownames(pro$X)
labels = gsub("site", "", labels)
# plot the results
par(mfrow = c(1, 2))
plot(pro, kind = 1, type = "n")
plot(pro, kind = 2)
par(mfrow = c(1,1))
plot(pro)
text(pro$X,
labels = labels,
col = "black",
pos = 4,
cex = 0.6
)
# perform procrustes randomization test
protest(X = results_1,
Y = results_4,
scores = "sites",
permutations = 9999)
# take out the scores from first two principal components
scores_1 = results_1$x[, 1:2]
scores_2 = results_2$x[, 1:2]
# check the dimensions - matrices must be the same dimensions
dim(scores_1)
dim(scores_2)
# make distance matrix from derived scores
dist_1 = dist(scores_1)
dist_2 = dist(scores_2)
# perform the Mantel test
mantel_result = mantel(dist_1,
dist_2,
method = "pearson",
permutations = 9999)
print(mantel_result)
# take out the scores from first two principal components
scores_1 = results_1$x[, 1:2]
scores_3 = results_3$x[, 1:2]
# check the dimensions - matrices must be the same dimensions
dim(scores_1)
dim(scores_3)
# make distance matrix from derived scores
dist_1 = dist(scores_1)
dist_3 = dist(scores_3)
# perform the Mantel test
mantel_result = mantel(dist_1,
dist_3,
method = "pearson",
permutations = 9999)
print(mantel_result)
scores_1 = results_1$x[, 1:2]
scores_4 = results_4$x[, 1:2]
# check the dimensions - matrices must be the same dimensions
dim(scores_1)
dim(scores_4)
# make distance matrix from derived scores
dist_1 = dist(scores_1)
dist_4 = dist(scores_4)
# perform the Mantel test
mantel_result = mantel(dist_1,
dist_4,
method = "pearson",
permutations = 9999)
print(mantel_result)
scores_2 = results_2$x[, 1:2]
scores_3 = results_3$x[, 1:2]
# check the dimensions - matrices must be the same dimensions
dim(scores_2)
dim(scores_3)
# make distance matrix from derived scores
dist_2 = dist(scores_2)
dist_3 = dist(scores_3)
# perform the Mantel test
mantel_result = mantel(dist_2,
dist_3,
method = "pearson",
permutations = 9999)
print(mantel_result)
# take out the scores from first two principal components
scores_2 = results_2$x[, 1:2]
scores_4 = results_4$x[, 1:2]
# check the dimensions - matrices must be the same dimensions
dim(scores_2)
dim(scores_4)
# make distance matrix from derived scores
dist_2 = dist(scores_2)
dist_4 = dist(scores_4)
# perform the Mantel test
mantel_result = mantel(dist_2,
dist_4,
method = "pearson",
permutations = 9999)
print(mantel_result
# take out the scores from first two principal components
scores_2 = results_2$x[, 1:2]
# take out the scores from first two principal components
scores_2 = results_2$x[, 1:2]
scores_4 = results_4$x[, 1:2]
# check the dimensions - matrices must be the same dimensions
dim(scores_2)
dim(scores_4)
# make distance matrix from derived scores
dist_2 = dist(scores_2)
dist_4 = dist(scores_4)
# perform the Mantel test
mantel_result = mantel(dist_2,
dist_4,
method = "pearson",
permutations = 9999)
print(mantel_result)
scores_3 = results_3$x[, 1:2]
scores_4 = results_4$x[, 1:2]
# check the dimensions - matrices must be the same dimensions
dim(scores_3)
dim(scores_4)
# make distance matrix from derived scores
dist_3 = dist(scores_3)
dist_4 = dist(scores_4)
# perform the Mantel test
mantel_result = mantel(dist_3,
dist_4,
method = "pearson",
permutations = 9999)
print(mantel_result)
# take out the scores from first two principal components
scores_3 = results_3$x[, 1:2]
scores_4 = results_3$x[, 1:2]
# check the dimensions - matrices must be the same dimensions
dim(scores_3)
dim(scores_4)
# make distance matrix from derived scores
dist_3 = dist(scores_3)
dist_4 = dist(scores_4)
# perform the Mantel test
mantel_result = mantel(dist_3,
dist_4,
method = "pearson",
permutations = 9999)
print(mantel_result)
# perform procrustes analyses
pro = procrustes(X = results_2,
Y = results_4,
symmetric = TRUE,
scale = TRUE)
print(pro)
labels = rownames(pro$X)
labels = gsub("site", "", labels)
par(mfrow = c(1,1))
plot(pro)
text(pro$X,
labels = labels,
col = "black",
pos = 4,
cex = 0.6
)
# perform procrustes randomization test
protest(X = results_2,
Y = results_4,
scores = "sites",
permutations = 9999)
print(pro)
labels = rownames(pro$X)
labels = gsub("site", "", labels)
par(mfrow = c(1,1))
plot(pro)
text(pro$X,
labels = labels,
col = "black",
pos = 4,
cex = 0.6
)
# perform procrustes randomization test
protest(X = results_2,
Y = results_4,
scores = "sites",
permutations = 9999)
# read and inspect dataframe
df_1 = read.csv('DPP1_omnic.csv')
df_2 = read.csv('DPP2_spectragryph.csv')
df_3 = read.csv('DPP3_openspecy_webapp.csv')
df_4 = read.csv('DPP4_openspecy_r.csv')
# remove rows with 0, else scaling wont work
df_1 = df_1[apply(df_1!=0, 1, all),]
df_2 = df_2[apply(df_2!=0, 1, all),]
df_3 = df_3[apply(df_3!=0, 1, all),]
df_4 = df_4[apply(df_4!=0, 1, all),]
# tranpose
df1_pca = t(df_1)
df2_pca = t(df_2)
df3_pca = t(df_3)
df4_pca = t(df_4)
# make first row column names
colnames(df1_pca) = as.character(unlist(df1_pca[1, ]))
colnames(df2_pca) = as.character(unlist(df2_pca[1, ]))
colnames(df3_pca) = as.character(unlist(df3_pca[1, ]))
colnames(df4_pca) = as.character(unlist(df4_pca[1, ]))
# replace previous column names and reset
df1_pca = df1_pca[-1, ]
rownames(df1_pca) = NULL
df2_pca = df2_pca[-1, ]
rownames(df2_pca) = NULL
df3_pca = df3_pca[-1, ]
rownames(df3_pca) = NULL
df4_pca = df4_pca[-1, ]
rownames(df4_pca) = NULL
# calculate PCs
results_1 = prcomp(df1_pca, scale=TRUE)
results_2 = prcomp(df2_pca, scale = TRUE)
results_3 = prcomp(df3_pca, scale = TRUE)
results_4 = prcomp(df4_pca, scale = TRUE)
# reverse eigenvectors
results_1$rotation = -1*results_1$rotation
results_2$rotation = -1*results_2$rotation
results_3$rotation = -1*results_3$rotation
results_4$rotation = -1*results_4$rotation
# dispay PCs
results_1$rotation
results_2$rotation
results_3$rotation
results_4$rotation
# perform procrustes analyses
pro = procrustes(X = results_3,
Y = results_4,
symmetric = TRUE,
scale = TRUE)
print(pro)
labels = rownames(pro$X)
labels = gsub("site", "", labels)
par(mfrow = c(1,1))
plot(pro)
text(pro$X,
labels = labels,
col = "black",
pos = 4,
cex = 0.6
)
# perform procrustes randomization test
protest(X = results_2,
Y = results_4,
scores = "sites",
permutations = 9999)
# perform procrustes randomization test
protest(X = results_3,
Y = results_4,
scores = "sites",
permutations = 9999)
head(gasoline)
data1 = data(gasoline)
install.packages("pls")
data1 = data(gasoline)
library(pls)
data1 = data(gasoline)
head(data1)
View(data1)
data(gasoline)
View(gasoline)
# lists of random columns
train_cols = c("Std_",
"Std_",
"Std_",
"Std_",
"Std_",
"Std_",
"Std_",
"Std_",
"Std_",
"Std_",
"Std_",
"Std_",
"Std_",
"Std_",
"Std_",
"Std_",
"Std_",
"Std_",
"Std_",)
# set up working directory
setwd("C:/Users/Lenovo/Documents/Programiranje/PhD/SpectralTool/datasets/plsr")
# import data
s1 = read.csv("for_split_omnic.csv")
s2 = read.csv("for_split_spectragryph.csv")
s3 = read.csv("for_split_openspecy_r.csv")
s4 = read.csv("for_split_openspecy_webapp.csv")
# inspect dataframes
View(s1)
View(s2)
View(s3)
View(s4)
# lists of random columns for training and testing data
train_cols = c("Std_9",  # 1
"Std_7",  # 2
"Std_29", # 3
"Std_12", # 4
"Std_17", # 5
"Std_14", # 6
"Std_19", # 7
"Std_16", # 8
"Std_23", # 9
"Std_22", # 10
"Std_3",  # 11
"Std_26", # 12
"Std_1",  # 13
"Std_2",  # 14
"Std_28", # 15
"Std_27", # 16
"Std_15", # 17
"Std_24", # 18
"Std_10", # 19
"Std_21", # 20
"Std_18", # 21
"Std_5",  # 22
"Std_6",  # 23
"Std_30", # 24
)
test_cols = c("Std_13", # 25
"Std_20", # 26
"Std_8",  # 27
"Std_11", # 28
"Std_4",  # 29
"Std_25", # 30
)
# lists of random columns for training and testing data
train_cols = c("Std_9",  # 1
"Std_7",  # 2
"Std_29", # 3
"Std_12", # 4
"Std_17", # 5
"Std_14", # 6
"Std_19", # 7
"Std_16", # 8
"Std_23", # 9
"Std_22", # 10
"Std_3",  # 11
"Std_26", # 12
"Std_1",  # 13
"Std_2",  # 14
"Std_28", # 15
"Std_27", # 16
"Std_15", # 17
"Std_24", # 18
"Std_10", # 19
"Std_21", # 20
"Std_18", # 21
"Std_5",  # 22
"Std_6",  # 23
"Std_30"  # 24
)
test_cols = c("Std_13", # 25
"Std_20", # 26
"Std_8",  # 27
"Std_11", # 28
"Std_4",  # 29
"Std_25"  # 30
)
# perform selection and save datasets
s1_train = s1 %>% select(all_of(train_cols))
# import libraries
library(dplyr)
# perform selection and save datasets
s1_train = s1 %>% select(all_of(train_cols))
s1_test = s1 %>% select(all_of(test_cols))
View(s1_train)
View(s1_test)
write.csv(s1_train, "DPP1_train.csv", row.names=FALSE)
write.csv(s1_test, "DPP1_test.csv", row.names=FALSE)
s2_train = s2 %>% select(all_of(train_cols))
s2_test = s2 %>% select(all_of(test_cols))
write.csv(s2_train, "DPP2_train.csv", row.names=FALSE)
write.csv(s2_test, "DPP2_test.csv", row.names=FALSE)
s3_train = s3 %>% select(all_of(train_cols))
s3_test = s3 %>% select(all_of(test_cols))
write.csv(s3_train, "DPP3_train.csv", row.names=FALSE)
write.csv(s3_test, "DPP3_test.csv", row.names=FALSE)
s4_train = s4 %>% select(all_of(train_cols))
s4_test = s4 %>% select(all_of(test_cols))
write.csv(s4_train, "DPP4_train.csv", row.names=FALSE)
write.csv(s4_test, "DPP4_test.csv", row.names=FALSE)
